//
//  PhotoLibraryManager.swift
//  PhotoScan
//
//  Created by Bensu Ã–zyurt on 16.09.2025.
//

import Foundation
import Photos
import SwiftUI
import CoreData
import os

class PhotoLibraryViewModel : ObservableObject {
    @Published var appPhotos: [AppPhoto] = []
    
    let context: NSManagedObjectContext
    //private let storageURL: URL (Decided to use Core Data instead so I do not need this anymore :) )
    private var processed  = 0
    private var alreadyProcessed = 0
    
    init(context: NSManagedObjectContext = PersistenceController.shared.container.viewContext) {
        self.context = context
        loadPhotos()
    }
    
    // Adds Photo assets to storage
    /*
        Param:
            Input:
            * asset : PHAsset
            * totalNumberOfPhotosThatIsGoingToProcessed : Int,
            * progressHandler : method that handless progress of downloading
            * completion: method that runs when the progress is over
            Output-> None
     */
    func addAsset(_ asset: PHAsset, total: Int, progressHandler: @escaping (Int, Int)->Void, completion: @escaping () -> Void) {
        let targetSize = CGSize(width: 300, height: 300)
        let options = PHImageRequestOptions() // We are making Image Request
        options.isSynchronous = true //                              !!!!!!!!! testing
        options.deliveryMode = .highQualityFormat
        // request image from PHImageManager
        PHImageManager.default().requestImage(for: asset, targetSize: targetSize, contentMode: .aspectFit, options: options) { image, _ in
            DispatchQueue.main.async  {
                let hash = asset.reliableHash()
                let date = asset.creationDate ?? Date()
                let group = PhotoGroup.group(for: hash)
                if !self.appPhotos.contains(where: { $0.id == asset.localIdentifier}) { // if photo does not exist
                    let newPhoto = self.savePhotos(with: asset.localIdentifier, for: hash, group: group, date: date) // then add it
                    self.appPhotos.append(newPhoto) // append the photo added to the array so we can achieve it without needing to use the DB
                    self.saveContext() // Save the db
                    self.processed += 1 // increase the processed
                }
                else {
                    self.alreadyProcessed += 1 // if image is already added, increase the already processed
                }
                progressHandler(self.processed, total - self.alreadyProcessed)
                if self.processed == (total - self.alreadyProcessed){ // when processed is equal to the total assets minus the ones we already added before
                    completion() // finish the proccess
                }
                
            }
            
        }
    }
    
    // Saves the added objects to CoreData
    // While working with core data, use context which is not the real db, so we should save every changes we made.
    private func saveContext() {
        guard context.hasChanges else {return}
        do {
            try context.save()
        }catch {
            NSLog("Error while saving context", error.localizedDescription)
        }
    }
    // Deletes Photo from Core Data
    /*
        Param:
            Input -> appPhoto: AppPhoto
            Output-> None
     */
    func deletePhoto(appPhoto : AppPhoto) {
        context.delete(appPhoto) //deletes app Photo.
        appPhotos.removeAll { $0.id == appPhoto.id } // remove the app photo from the appPhoto array as well
        saveContext()
    }
    
    // Saves Photo's to Core Data
    /*
        Param:
            Input:
            * localIdentifier : String (it is the local identifier of the image stored in our local photo library)
            * hash: Double (group has generated by the PhotoGroup)
            * group : PhotoGroup? (if it is nil we are going to store the name of the group as Other)
            Output-> photo: AppPhoto  (returns the added photo)
     */
    private func savePhotos(with localIdentifier: String, for hash: Double, group: PhotoGroup?, date: Date) -> AppPhoto {
        let newPhoto = AppPhoto(context: self.context)
        newPhoto.id = localIdentifier
        newPhoto.groupHash = hash
        newPhoto.groupName = group?.rawValue ?? "Other"
        newPhoto.creationDate = date
        return newPhoto
    }
    
    
    // Loads every AppPhoto data from the memory
    /*
        Param:
            Input -> None
            Output-> None
     */
    func loadPhotos() {
        let request : NSFetchRequest<AppPhoto> = AppPhoto.fetchRequest() // request every AppPhoto
        do {
            let result = try context.fetch(request) // fetch it from the context
            self.appPhotos = result //load added photos to appPhoto array
            // DO NOT APPEND!! The reason we reinitialize is because the we are loading the already added photos. If you add it again, there will me multiple of same photo.
        }catch { // if there is any error while fetching
            NSLog("Error while fetching photos", error.localizedDescription)
            self.appPhotos = []
        }
    }
    
    // I might add this function to GroupDetailScreen View Model in future.
    // Fetches Images from Photo Library
    func fetchImage(for appPhoto: AppPhoto,targetSize: CGSize, completion: @escaping (UIImage?) -> Void) {
        let options = PHImageRequestOptions()
        options.isSynchronous = false
        options.deliveryMode = .opportunistic
        
        // There should be an id of the photo else return nothing.
        guard let id = appPhoto.id else {
            completion(nil)
            return
        }
        let assets = PHAsset.fetchAssets(withLocalIdentifiers: [id], options: nil)
        if let asset = assets.firstObject {
            PHImageManager.default().requestImage(
                for: asset,
                targetSize: targetSize,
                contentMode: .aspectFill,
                options: options
            ) { image, _ in
                completion(image)
            }
        }
            
    }

}
